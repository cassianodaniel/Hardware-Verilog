DELAY: #20 //20 pulsos de clock para executar alguma determinada tarefa
O TEMPO DEPENDE, BASICAMENTE, DA FREQUÊNCIA DO REGISTRADOR (50MHZ, 40MHZ...)
ASSIGN #5 X = Y + Z (COM ATRASO) ----> Y + Z, MUDANDO DE VALOR, VÃO ADIANTAREM-SE 5 PULSOS DE CLOCK NA FRENTE DE X

ASSIGN IMPLÍCITO
WIRE TESTE = A + B;

ASSIGN EXPLÍCITO
ASSIGN TESTE = A+ B;

OUTPUT =! ASSIGN / ASSIGN CI'S DENTRO DO MÓDULO, OUTPUT = SAÍDA DO MÓDULO

ASSIGN = UTILIZADO EM MODELOS COMBINACIONAIS
INITIAL E ALWAYS SÃO BLOCOS! VÁRIAS ATRIBUIÇÕES EM UM BLOCO SÓ.
INITIAL = SIMULAÇÕES //SÃO COMO COMENTÁRIOS NA HORA DE SINTETIZAR
ALWAYS = CONCRETIZAÇÃO DE PROJETO

INITIAL = LÊ SOMENTE UMA VEZ A INSTRUÇÃO, POR EXEMPLO:

INITIAL
BEGIN
  VAR_01 = 1'B0;
  #3 C = D;
 END

VAR_01 SÓ SERA LIDA APENAS UMA VEZ

BEGIN E END SÃO COMO CHAVES EM C{} //SÓ PODEM APARECER APÓS DUAS DECLARAÇÕES ---> DE QUE TIPO?;

INITIAL{ //OU ALWAYS
  TUDO O QUE TIVER AQUI SERÁ ASSUMIDO COMO ASSIGN
  NÃO PODE DECLARAR ASSIGNS AQUI DENTRO!!!! (NEM EM ALWAYS)
END}

ALWAYS PODE SER EXECUTADO VÁRIAS VEZES =! INITIAL QUE PODE SER EXECUTADO APENAS UMA VEZ E NA SINTETIZAÇÃO /*SINTETIZADO = GERAR UM HARDWARE OU CI*/ ELE É TRANSPARENTE

OS BLOCO ALWAYS SÃO EXECUTADOS EM PARALELO, PORÉM A PARTE DE DENTRO DOS BLOCOS ALWAYS SÃO SEQUENCIAIS
  
  ALWAYS1{//EXECUTA AO MESMO TEMPO QUE ALWAYS2 
//PRIORIDADE DE EXECUÇÃO DENTRO DO BLOCO: 
  1º EXEC --> C = D
  2º EXEC --> D = E
  3º EXEC --> A = B
  }
  ALWAYS2{//EXECUTA AO MESMO TEMPO QUE ALWAYS1
  1º EXEC --> J = K 
  2º EXEC --> K = L
  3º EXEC --> O = A
  }
  
  LISTA DE SENSIBILIDADE: QUEM VAI DIZER QUE O ALWAYS VAI SER REPETIDO NOVAMENTE
  
  ALWAYS@(/*CONJUNTO DE SENSIBILIDADE*/) BEGIN //(PARECE COM WHILE ---> EXECUTE O ALWAYS TODA VEZ QUE O CONJUNTO DE SENSIBILIDADE MUDAR)
  ALWAYS@(X && Y) BEGIN //SE X E Y MUDAREM, EXECUTE ALWAYS
  ALWAYS@(CLOCK) BEGIN
  ALWAYS@(POS EDGE(CLK)) BEGIN //QUANDO A BORDA DE SUBIDA FOR ACIONADA, EXECUTE CLOCK
  ALWAYS@(*)//SE QUALQUER ENTRADA MUDAR, EXECUTE ALWAYS NOVAMENTE
  ALWAYS() //SEM CONJUNTO DE SENSIBILIDADE, EXECUTA APENAS UMA VEZ
  
  OS BLOCOS NÃO PODEM SER ALINHADOS : INICIAL DENTRO DE INICIAL OU ALWAYS DENTRO DE ALWAYS;
  
  PARALELISMO OU NONBLOCKING:
  EM VEZ DE DECLARAR X = B, DECLARE X <= B;
  
  A DIFERENÇA ENTRE A SEQUÊNCIA DE INSTRUÇÕES BLOCKING E NÃO BLOCKING É:
  
  BLOCKING:
X = 1; //1º
Y = 2; //2º
Z = 3; //3º

  NONBLOCKING:
X <= Y; //AO MESMO TEMPO
Y <= 2; //AO MESMO TEMPO
Z <= 3; //AO MESMO TEMPO

BLOCOS ALWAYS E INITIAL SÃO SEQUENCIAIS OU PARALELOS
O QUE ESTÃO DENTRO DOS BLOCOS PODEM SER OU NÃO SEQUENCIAIS, DE ACORDO COM NONBLOCKING OU BLOCKING DE VARIÁVEIS

CASES
SE O CASE TIVER MAIS DE DUAS INSTRUÇÕES DENTRO DELE, ENTÃO É NECESSÁRIO COLOCAR UM BEGIN E UM END

FOREVER = WHILE(1)
REPEAT = (VOCÊ DECIDE A QUANTIDADE DE VEZES A SER REPETIDO)
SE TIVER MAIS DE DUAS INSTRUÇÕES DENTRO DELE, ENTÃO É NECESSÁRIO COLOCAR UM BEGIN E UM END

RETURN = NOME DA FUNÇÃO
FUNCTION[15:0] MULT
{CORPO
DA
FUNÇÃO
}
//PÉ DA FUNÇÃO
MULT = R
ENDFUNCTION

TAREFAS SÃO MAIS PODEROSAS QUE AS FUNÇÕES
TAREFAS NÃO PRECISAM DE PARÂMETRO
FUNÇÕES PRECISAM DE PARÂMETRO

EXEMPLO DE TAREFA E UMA FUNÇÃO:
TAREFA:
MODULE TASKS 
TASK ADD
  INPUT A,B;
  OUTPUT C;
BEGIN 
  C = A+B;
END

FUNÇÃO CHAMANDO PARÂMETRO DA TAREFA:
INITIAL
BEGIN: INIT1
  REG P;
  ADD(1,0,p) // a é 1, b é 0 e output é p ====== de acordo com a tarefa declarada acima
  &display("p=%b%, p);
 end
  
